<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Get funded now</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=VT323&display=swap" rel="stylesheet">
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/gsap.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/ScrollTrigger.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        body {
            background-color: #000000;
            color: #e5e7eb; /* gray-200 */
            font-family: 'VT323', monospace;
        }
        /* Custom scrollbar */
        body::-webkit-scrollbar {
            width: 8px;
        }
        body::-webkit-scrollbar-track {
            background: #000;
        }
        body::-webkit-scrollbar-thumb {
            background: #9ca3af; /* gray-400 */
            border-radius: 4px;
        }
        body::-webkit-scrollbar-thumb:hover {
            background: #d1d5db; /* gray-300 */
        }

        /* Canvas for the 3D globe */
        #globe-canvas {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
        }

        /* Noise overlay for grainy effect */
        #noise-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 2;
            pointer-events: none;
            opacity: 0.1;
            background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADIAAAAyCAMAAAAp4XiDAAAAUVBMVEWFhYWDg4N3d3dtbW17e3t1dXWBgYGHh4d5eXlzc3OLi4ubm5uVlZWPj4+NjY19fX2JiYl/f39ra2uRkZGZmZlpaWmXl5dvb29xcXGTk5NnZ2c8TV1mAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAIGNIUk0AAHolAACAgwAA+f8AAIDpAAB1MAAA6mAAADqYAAAXb5JfxUYAAABnSURBVEjHqmdSDoAgDARBk2/4+z8uVwVRQLvbIeQFCJecDqYq2v4kE2Y6IvdgObyIeRCHGvjTMsQYECUeM3oB3A2U5fAogLHYuA2A4gPYoJwH3gRy5xHlJ2QnzssD8A+gL2d3sKkAAAAASUVORK5CYII=');
        }

        /* Container for the text content */
        .content-container {
            position: relative;
            z-index: 3; /* On top of globe and noise */
            width: 100%;
        }

        /* Individual text sections */
        .content-section {
            min-height: 120vh; /* Increased height for more scroll room */
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 2rem;
        }
    </style>
</head>
<body>

    <!-- The canvas where the Three.js globe will be rendered -->
    <canvas id="globe-canvas"></canvas>
    <div id="noise-overlay"></div>

    <!-- This container holds all the scrolling text content -->
    <div class="content-container">
        
        <!-- Section 1 -->
        <section class="content-section" data-torch-target="true">
            <div class="text-center max-w-4xl">
                <h2 class="text-5xl md:text-7xl font-bold mb-4 leading-tight">Unlock Your True Potential</h2>
            </div>
        </section>

        <!-- Section 2 -->
        <section class="content-section" data-torch-target="true">
            <div class="text-left w-full max-w-6xl ml-auto">
                <h2 class="text-5xl md:text-7xl font-bold mb-4 leading-tight">Get Funded Now</h2>
            </div>
        </section>

        <!-- Section 3 -->
        <section class="content-section" data-torch-target="true">
            <div class="text-right w-full max-w-6xl mr-auto">
                <h2 class="text-4xl md:text-6xl font-bold mb-4 leading-tight">
                    When life says ‘no capital’ GainVault says ‘hold my vault’
                </h2>
            </div>
        </section>
        
    </div>

    <script>
        // Register GSAP plugins
        gsap.registerPlugin(ScrollTrigger);

        // --- THREE.JS SETUP ---
        const scene = new THREE.Scene();
        const clock = new THREE.Clock();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({
            canvas: document.querySelector('#globe-canvas'),
            alpha: true
        });

        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.setSize(window.innerWidth, window.innerHeight);
        camera.position.setZ(40);

        // --- CREATING THE GLOBE ---
        const globeGroup = new THREE.Group();
        scene.add(globeGroup);
        const GLOBE_RADIUS = 15;

        // Core of the globe
        const coreGeometry = new THREE.SphereGeometry(GLOBE_RADIUS, 64, 64);
        const coreMaterial = new THREE.MeshStandardMaterial({ color: 0x1a1a1a, roughness: 0.7, metalness: 0.1 });
        const core = new THREE.Mesh(coreGeometry, coreMaterial);
        globeGroup.add(core);

        // --- STATIC DOTS ---
        const pointsGeometry = new THREE.SphereGeometry(GLOBE_RADIUS + 0.1, 45, 45);
        const pointsMaterial = new THREE.PointsMaterial({
            color: 0xffffff,
            size: 0.2,
            blending: THREE.AdditiveBlending,
            depthWrite: false,
            transparent: true,
            opacity: 0.7
        });
        const points = new THREE.Points(pointsGeometry, pointsMaterial);
        globeGroup.add(points);
        
        // Concentric rings around the globe
        for (let i = 1; i <= 3; i++) {
            const ringGeometry = new THREE.RingGeometry(GLOBE_RADIUS + i * 2, GLOBE_RADIUS + i * 2 + 0.1, 128);
            const ringMaterial = new THREE.MeshBasicMaterial({ color: 0x444444, side: THREE.DoubleSide, transparent: true, opacity: 0.5 });
            const ring = new THREE.Mesh(ringGeometry, ringMaterial);
            ring.rotation.x = Math.PI / 2;
            globeGroup.add(ring);
        }

        // --- LIGHTING ---
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
        scene.add(ambientLight);
        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
        directionalLight.position.set(50, 20, 30);
        scene.add(directionalLight);

        // --- DYNAMIC STARFIELD BACKGROUND ---
        const starGeometry = new THREE.BufferGeometry();
        const starVertices = [];
        for (let i = 0; i < 10000; i++) {
            const x = (Math.random() - 0.5) * 2000;
            const y = (Math.random() - 0.5) * 2000;
            const z = (Math.random() - 0.5) * 2000;
            starVertices.push(x, y, z);
        }
        starGeometry.setAttribute('position', new THREE.Float32BufferAttribute(starVertices, 3));
        const starMaterial = new THREE.PointsMaterial({
            color: 0xaaaaaa,
            size: 0.7,
            transparent: true
        });
        const stars = new THREE.Points(starGeometry, starMaterial);
        scene.add(stars);


        // --- TORCHLIGHT EFFECT ---
        const torchLights = [];
        const contentSections = gsap.utils.toArray('.content-section[data-torch-target]');

        const beamCanvas = document.createElement('canvas');
        const beamContext = beamCanvas.getContext('2d');
        beamCanvas.width = 64;
        beamCanvas.height = 64;
        const gradient = beamContext.createRadialGradient(32, 32, 0, 32, 32, 32);
        gradient.addColorStop(0, 'rgba(255,255,255,1)');
        gradient.addColorStop(1, 'rgba(255,255,255,0)');
        beamContext.fillStyle = gradient;
        beamContext.fillRect(0, 0, 64, 64);
        const beamTexture = new THREE.CanvasTexture(beamCanvas);

        contentSections.forEach((section, i) => {
            const beamGeometry = new THREE.CylinderGeometry(0, 1.5, 50, 32, 1, true);
            const beamMaterial = new THREE.MeshBasicMaterial({
                map: beamTexture,
                blending: THREE.AdditiveBlending,
                depthWrite: false,
                transparent: true,
                opacity: 0
            });
            const torch = new THREE.Mesh(beamGeometry, beamMaterial);
            scene.add(torch);
            torchLights.push(torch);
        });

        // --- SCROLL ANIMATION ---
        const tl = gsap.timeline({
            scrollTrigger: {
                trigger: '.content-container',
                start: 'top top',
                end: 'bottom bottom',
                scrub: 1,
            }
        });
        tl.to(globeGroup.rotation, { y: Math.PI * 1.5 }, 0);
        tl.to(globeGroup.scale, { x: 2.5, y: 2.5, z: 2.5 }, 0);
        tl.to(camera.position, { z: 35 }, 0);

        contentSections.forEach((section, i) => {
            gsap.fromTo(section.querySelector('div'), 
                { opacity: 0, scale: 0.2 },
                {
                    opacity: 1, 
                    scale: 1,
                    ease: 'power3.out',
                    scrollTrigger: {
                        trigger: section,
                        start: 'top 70%',
                        end: 'top 40%',
                        scrub: 1.5,
                    }
                }
            );
            
            const torch = torchLights[i];
            gsap.timeline({
                scrollTrigger: {
                    trigger: section,
                    start: 'top 80%',
                    end: 'bottom top',
                    scrub: 1,
                    onUpdate: (self) => {
                        const progress = self.progress;
                        const elapsedTime = clock.getElapsedTime();
                        const contentRect = section.getBoundingClientRect();
                        const targetVector = new THREE.Vector3(
                            (contentRect.left + contentRect.width / 2) / window.innerWidth * 2 - 1,
                            -(contentRect.top + contentRect.height / 2) / window.innerHeight * 2 + 1,
                            0.5
                        );
                        targetVector.unproject(camera);
                        torch.position.set(0, 0, 0);
                        torch.lookAt(targetVector);
                        
                        // Base opacity on scroll progress (fade in/out)
                        const baseOpacity = Math.sin(progress * Math.PI);

                        // Add a rapid flicker effect on top of the base opacity
                        const flickerSpeed = 30;
                        const flicker = Math.floor(elapsedTime * flickerSpeed) % 2 === 0 ? 1.0 : 0.4;

                        // Combine them
                        torch.material.opacity = baseOpacity * flicker;
                    }
                }
            });
        });

        // --- MOUSE INTERACTION ---
        let mouseX = 0;
        let mouseY = 0;
        document.addEventListener('mousemove', (event) => {
            mouseX = (event.clientX / window.innerWidth) * 2 - 1;
            mouseY = -(event.clientY / window.innerHeight) * 2 + 1;
        });

        // --- RENDER LOOP ---
        function animate() {
            requestAnimationFrame(animate);

            // Animate stars
            const positions = starGeometry.attributes.position.array;
            for (let i = 0; i < positions.length; i += 3) {
                positions[i + 2] += 0.3; // Move star along z-axis
                if (positions[i + 2] > 1000) {
                    positions[i + 2] = -1000; // Reset star if it goes past camera
                }
            }
            starGeometry.attributes.position.needsUpdate = true;

            globeGroup.rotation.y += 0.0002;
            camera.position.x += (mouseX * 2 - camera.position.x) * 0.02;
            camera.position.y += (mouseY * 2 - camera.position.y) * 0.02;
            camera.lookAt(scene.position);
            renderer.render(scene, camera);
        }
        animate();

        // --- RESIZE HANDLER ---
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

    </script>

</body>
</html>
